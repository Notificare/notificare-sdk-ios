// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4 (swiftlang-1205.0.26.9 clang-1205.0.19.55)
// swift-module-flags: -target i386-apple-ios10.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name NotificareKit
import CoreData
import Foundation
@_exported import NotificareKit
import Swift
import SystemConfiguration
import UIKit
import os
public typealias NotificareCallback<T> = (Swift.Result<T, Swift.Error>) -> Swift.Void
@_hasMissingDesignatedInitializers public class Notificare {
  public static let shared: NotificareKit.Notificare
  final public let eventsManager: NotificareKit.NotificareEventsModule
  final public let deviceManager: NotificareKit.NotificareDeviceManager
  public var servicesInfo: NotificareKit.NotificareServicesInfo? {
    get
  }
  public var options: NotificareKit.NotificareOptions? {
    get
  }
  public var application: NotificareKit.NotificareApplication? {
    get
  }
  weak public var delegate: NotificareKit.NotificareDelegate?
  public var useAdvancedLogging: Swift.Bool {
    get
    set
  }
  public var isConfigured: Swift.Bool {
    get
  }
  public var isReady: Swift.Bool {
    get
  }
  public func configure(servicesInfo: NotificareKit.NotificareServicesInfo? = nil, options: NotificareKit.NotificareOptions? = nil)
  public func configure(servicesInfo: NotificareKit.NotificareServicesInfo, options: NotificareKit.NotificareOptions)
  public func launch()
  public func unlaunch()
  public func fetchApplication(_ completion: @escaping NotificareKit.NotificareCallback<NotificareKit.NotificareApplication>)
  public func fetchDynamicLink(_ link: Swift.String, _ completion: @escaping NotificareKit.NotificareCallback<NotificareKit.NotificareDynamicLink>)
  public func fetchNotification(_ id: Swift.String, _ completion: @escaping NotificareKit.NotificareCallback<NotificareKit.NotificareNotification>)
  public func createNotificationReply(notification: NotificareKit.NotificareNotification, action: NotificareKit.NotificareNotification.Action, message: Swift.String? = nil, media: Swift.String? = nil, mimeType: Swift.String? = nil, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  public func callNotificationReplyWebhook(url: Foundation.URL, data: [Swift.String : Swift.String], _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  public func uploadNotificationReplyAsset(_ data: Foundation.Data, contentType: Swift.String, _ completion: @escaping NotificareKit.NotificareCallback<Swift.String>)
  public func removeNotificationFromNotificationCenter(_ notification: NotificareKit.NotificareNotification)
  public func handleTestDeviceUrl(_ url: Foundation.URL) -> Swift.Bool
  public func handleDynamicLinkUrl(_ url: Foundation.URL) -> Swift.Bool
  @objc deinit
}
public enum NotificareIsoDateUtils {
  public static func parse(_ date: Swift.String) -> Foundation.Date?
  public static func format(_ date: Foundation.Date) -> Swift.String
}
open class NotificareAbstractDatabase {
  public var persistentContainer: CoreData.NSPersistentContainer {
    get
    set
  }
  public var context: CoreData.NSManagedObjectContext {
    get
  }
  public init(name: Swift.String, rebuildOnVersionChange: Swift.Bool = true)
  public func configure()
  public func saveChanges()
  @objc deinit
}
public struct NotificareDynamicLink : Swift.Codable {
  public let target: Swift.String
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareDynamicLink
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol NotificareDelegate : AnyObject {
  func notificare(_ notificare: NotificareKit.Notificare, onReady application: NotificareKit.NotificareApplication)
  func notificare(_ notificare: NotificareKit.Notificare, didRegisterDevice device: NotificareKit.NotificareDevice)
}
extension NotificareDelegate {
  public func notificare(_: NotificareKit.Notificare, didRegisterDevice _: NotificareKit.NotificareDevice)
}
public protocol NotificareModule {
  static func migrate()
  static func configure()
  static func launch(_ completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  static func unlaunch(_ completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
}
extension NotificareModule {
  public static func migrate()
}
extension URL {
  public func appendingQueryComponent(name: Swift.String, value: Swift.String) -> Foundation.URL
  public mutating func appendQueryComponent(name: Swift.String, value: Swift.String)
}
public enum NotificareError : Swift.Error {
  case generic(message: Swift.String, cause: Swift.Error? = nil)
  case notReady
  case networkFailure(cause: NotificareKit.NotificareNetworkError)
  case encodingFailure
  case parsingFailure
  case invalidLanguageCode
  case invalidArgument
}
public struct NotificareApplication : Swift.Codable {
  public let id: Swift.String
  public let name: Swift.String
  public let category: Swift.String
  public let appStoreId: Swift.String?
  public let services: [Swift.String : Swift.Bool]
  public let inboxConfig: NotificareKit.NotificareApplication.InboxConfig?
  public let regionConfig: NotificareKit.NotificareApplication.RegionConfig?
  public let userDataFields: [NotificareKit.NotificareApplication.UserDataField]
  public let actionCategories: [NotificareKit.NotificareApplication.ActionCategory]
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareApplication
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension NotificareApplication {
  public struct InboxConfig : Swift.Codable {
    public let useInbox: Swift.Bool
    public let autoBadge: Swift.Bool
    public func toJson() throws -> [Swift.String : Any]
    public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareApplication.InboxConfig
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
}
extension NotificareApplication {
  public struct RegionConfig : Swift.Codable {
    public let proximityUUID: Swift.String?
    public func toJson() throws -> [Swift.String : Any]
    public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareApplication.RegionConfig
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
}
extension NotificareApplication {
  public struct UserDataField : Swift.Codable {
    public let type: Swift.String
    public let key: Swift.String
    public let label: Swift.String
    public func toJson() throws -> [Swift.String : Any]
    public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareApplication.UserDataField
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
}
extension NotificareApplication {
  public struct ActionCategory : Swift.Codable {
    public let name: Swift.String
    public let description: Swift.String?
    public let type: Swift.String
    public let actions: [NotificareKit.NotificareApplication.ActionCategory.Action]
    public func toJson() throws -> [Swift.String : Any]
    public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareApplication.ActionCategory
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
}
extension NotificareApplication.ActionCategory {
  public struct Action : Swift.Codable {
    public let type: Swift.String
    public let label: Swift.String
    public let target: Swift.String?
    public let camera: Swift.Bool
    public let keyboard: Swift.Bool
    public let destructive: Swift.Bool
    public func toJson() throws -> [Swift.String : Any]
    public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareApplication.ActionCategory.Action
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
}
public enum NotificareLogger {
  public static var useAdvancedLogging: Swift.Bool
  public static func debug(_ message: Swift.String, file: Swift.String = #file)
  public static func debug(_ message: Swift.String, tag: Swift.String?)
  public static func info(_ message: Swift.String, file: Swift.String = #file)
  public static func info(_ message: Swift.String, tag: Swift.String?)
  public static func warning(_ message: Swift.String, file: Swift.String = #file)
  public static func warning(_ message: Swift.String, tag: Swift.String?)
  public static func error(_ message: Swift.String, file: Swift.String = #file)
  public static func error(_ message: Swift.String, tag: Swift.String?)
}
@objc public protocol NotificareAppDelegateInterceptor {
  @objc optional func applicationDidBecomeActive(_ application: UIKit.UIApplication)
  @objc optional func applicationWillResignActive(_ application: UIKit.UIApplication)
  @objc optional func application(_ application: UIKit.UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Foundation.Data)
  @objc optional func application(_ application: UIKit.UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Swift.Error)
  @objc optional func application(_ application: UIKit.UIApplication, didReceiveRemoteNotification userInfo: [Swift.AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIKit.UIBackgroundFetchResult) -> Swift.Void)
  @objc optional func application(_ app: UIKit.UIApplication, open url: Foundation.URL, options: [UIKit.UIApplication.OpenURLOptionsKey : Any]) -> Swift.Bool
  @objc optional func application(_ application: UIKit.UIApplication, continue userActivity: Foundation.NSUserActivity, restorationHandler: @escaping ([UIKit.UIUserActivityRestoring]?) -> Swift.Void) -> Swift.Bool
}
public enum NotificareNetworkError : Swift.Error {
  case inaccessible
  case urlError(Foundation.URLError)
  case genericError(Swift.Error)
  case noResponse
  case invalidResponseType(Foundation.URLResponse)
  case noResponseData(Foundation.HTTPURLResponse)
  case endpointError(Foundation.HTTPURLResponse, Foundation.Data?)
  case validationError(response: Foundation.HTTPURLResponse, data: Foundation.Data?, validStatusCodes: Swift.ClosedRange<Swift.Int>)
}
extension NotificareNetworkError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class NotificareAutoConfig : ObjectiveC.NSObject {
  @objc public static func setup()
  @objc public static func didFinishLaunching(_: Foundation.Notification)
  @objc override dynamic public init()
  @objc deinit
}
public struct NotificareNotification {
  public let partial: Swift.Bool
  public let id: Swift.String
  public let type: Swift.String
  public let time: Foundation.Date
  public let title: Swift.String?
  public let subtitle: Swift.String?
  public let message: Swift.String
  public let content: [NotificareKit.NotificareNotification.Content]
  public let actions: [NotificareKit.NotificareNotification.Action]
  public let attachments: [NotificareKit.NotificareNotification.Attachment]
  public let extra: [Swift.String : Any]
  public let targetContentIdentifier: Swift.String?
  public init(partial: Swift.Bool, id: Swift.String, type: Swift.String, time: Foundation.Date, title: Swift.String?, subtitle: Swift.String?, message: Swift.String, content: [NotificareKit.NotificareNotification.Content], actions: [NotificareKit.NotificareNotification.Action], attachments: [NotificareKit.NotificareNotification.Attachment], extra: [Swift.String : Any], targetContentIdentifier: Swift.String?)
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareNotification
}
extension NotificareNotification : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension NotificareNotification {
  public enum NotificationType : Swift.String {
    case none
    case alert
    case webView
    case url
    case urlScheme
    case image
    case video
    case map
    case rate
    case passbook
    case store
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension NotificareNotification {
  public struct Content : Swift.Codable {
    public let type: Swift.String
    public let data: Any
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
    public func toJson() throws -> [Swift.String : Any]
    public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareNotification.Content
  }
}
extension NotificareNotification {
  public struct Action : Swift.Codable {
    public let type: Swift.String
    public let label: Swift.String
    public let target: Swift.String?
    public let keyboard: Swift.Bool
    public let camera: Swift.Bool
    public func toJson() throws -> [Swift.String : Any]
    public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareNotification.Action
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
}
extension NotificareNotification.Action {
  public enum ActionType : Swift.String {
    case app
    case browser
    case callback
    case custom
    case mail
    case sms
    case telephone
    case webView
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension NotificareNotification {
  public struct Attachment : Swift.Codable {
    public let mimeType: Swift.String
    public let uri: Swift.String
    public init(mimeType: Swift.String, uri: Swift.String)
    public func toJson() throws -> [Swift.String : Any]
    public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareNotification.Attachment
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
}
@frozen public struct AnyEncodable : Swift.Encodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyEncodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension AnyEncodable : NotificareKit._AnyEncodable {
}
extension _AnyEncodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension AnyEncodable : Swift.Equatable {
  public static func == (lhs: NotificareKit.AnyEncodable, rhs: NotificareKit.AnyEncodable) -> Swift.Bool
}
extension AnyEncodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AnyEncodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension AnyEncodable : Swift.ExpressibleByNilLiteral {
}
extension AnyEncodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension AnyEncodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension AnyEncodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension AnyEncodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension AnyEncodable : Swift.ExpressibleByStringInterpolation {
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
}
extension AnyEncodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension AnyEncodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
extension _AnyEncodable {
  public init(nilLiteral _: ())
  public init(booleanLiteral value: Swift.Bool)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(arrayLiteral elements: Any...)
  public init(dictionaryLiteral elements: (Swift.AnyHashable, Any)...)
}
public struct NotificareTime {
  public let hours: Swift.Int
  public let minutes: Swift.Int
  public init(hours: Swift.Int, minutes: Swift.Int) throws
  public init(string: Swift.String) throws
  public func format() -> Swift.String
}
extension NotificareTime : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public typealias NotificareUserData = [Swift.String : Swift.String]
public struct NotificareDevice : Swift.Codable {
  public let id: Swift.String
  public var userId: Swift.String? {
    get
  }
  public var userName: Swift.String? {
    get
  }
  public var timeZoneOffset: Swift.Float {
    get
  }
  public var osVersion: Swift.String {
    get
  }
  public var sdkVersion: Swift.String {
    get
  }
  public var appVersion: Swift.String {
    get
  }
  public var deviceString: Swift.String {
    get
  }
  public var language: Swift.String {
    get
  }
  public var region: Swift.String {
    get
  }
  public var transport: NotificareKit.NotificareTransport {
    get
  }
  public var dnd: NotificareKit.NotificareDoNotDisturb? {
    get
  }
  public var userData: NotificareKit.NotificareUserData {
    get
  }
  public var lastRegistered: Foundation.Date {
    get
  }
  public var backgroundAppRefresh: Swift.Bool {
    get
  }
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareDevice
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum NotificareUtils {
  public static var applicationName: Swift.String? {
    get
  }
  public static var applicationVersion: Swift.String {
    get
  }
  public static var deviceString: Swift.String {
    get
  }
  public static var deviceLanguage: Swift.String {
    get
  }
  public static var deviceRegion: Swift.String {
    get
  }
  public static var osVersion: Swift.String {
    get
  }
  public static var timeZoneOffset: Swift.Float {
    get
  }
  public static func getLoadedModules() -> [Swift.String]
  public static let jsonDecoder: Foundation.JSONDecoder
  public static let jsonEncoder: Foundation.JSONEncoder
}
public struct NotificareServicesInfo : Swift.Decodable {
  public let applicationKey: Swift.String
  public let applicationSecret: Swift.String
  public init(applicationKey: Swift.String, applicationSecret: Swift.String)
  public init?(contentsOfFile plistPath: Swift.String)
  public init(from decoder: Swift.Decoder) throws
}
@objc @_inheritsConvenienceInitializers public class NotificareSwizzler : Foundation.NSProxy {
  public static func setup(withRemoteNotifications: Swift.Bool = false)
  public static func addInterceptor(_ interceptor: NotificareKit.NotificareAppDelegateInterceptor) -> Swift.String?
  public static func removeInterceptor(_ interceptor: NotificareKit.NotificareAppDelegateInterceptor)
  @objc deinit
}
extension KeyedDecodingContainer {
  public func decode(_ type: [Swift.String : Any].Type, forKey key: K) throws -> [Swift.String : Any]
  public func decodeIfPresent(_ type: [Swift.String : Any].Type, forKey key: K) throws -> [Swift.String : Any]?
  public func decode(_ type: [Any].Type, forKey key: K) throws -> [Any]
  public func decodeIfPresent(_ type: [Any].Type, forKey key: K) throws -> [Any]?
  public func decode(_: [Swift.String : Any].Type) throws -> [Swift.String : Any]
}
extension UnkeyedDecodingContainer {
  public mutating func decode(_: [Any].Type) throws -> [Any]
  public mutating func decode(_ type: [Swift.String : Any].Type) throws -> [Swift.String : Any]
}
public typealias NotificareEventData = NotificareKit.JSON
public struct NotificareEvent {
  public let type: Swift.String
  public let timestamp: Swift.Int64
  public let deviceId: Swift.String?
  public let sessionId: Swift.String?
  public let notificationId: Swift.String?
  public let userId: Swift.String?
  public let data: NotificareKit.NotificareEventData?
}
extension NotificareEvent : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum NotificareTransport : Swift.String, Swift.Codable {
  case notificare
  case apns
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
extension NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class NotificareReachability {
  public typealias NetworkReachable = (NotificareKit.NotificareReachability) -> Swift.Void
  public typealias NetworkUnreachable = (NotificareKit.NotificareReachability) -> Swift.Void
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: NotificareKit.NotificareReachability.Connection, b: NotificareKit.NotificareReachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: NotificareKit.NotificareReachability.NetworkReachable?
  public var whenUnreachable: NotificareKit.NotificareReachability.NetworkUnreachable?
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  public var connection: NotificareKit.NotificareReachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension NotificareReachability {
  public func startNotifier() throws
  public func stopNotifier()
  public var description: Swift.String {
    get
  }
}
@frozen public struct AnyCodable : Swift.Codable {
  public let value: Any
  public init<T>(_ value: T?)
}
extension AnyCodable : NotificareKit._AnyEncodable, NotificareKit._AnyDecodable {
}
extension AnyCodable : Swift.Equatable {
  public static func == (lhs: NotificareKit.AnyCodable, rhs: NotificareKit.AnyCodable) -> Swift.Bool
}
extension AnyCodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AnyCodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension AnyCodable : Swift.ExpressibleByNilLiteral {
}
extension AnyCodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension AnyCodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension AnyCodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension AnyCodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension AnyCodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension AnyCodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
public enum NotificareDefinitions {
  public enum Modules : Swift.String, Swift.CaseIterable {
    case push
    case pushUI
    case inbox
    public init?(rawValue: Swift.String)
    public typealias AllCases = [NotificareKit.NotificareDefinitions.Modules]
    public typealias RawValue = Swift.String
    public static var allCases: [NotificareKit.NotificareDefinitions.Modules] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
public struct NotificareDoNotDisturb : Swift.Codable {
  public let start: NotificareKit.NotificareTime
  public let end: NotificareKit.NotificareTime
  public init(start: NotificareKit.NotificareTime, end: NotificareKit.NotificareTime)
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareDoNotDisturb
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@frozen public struct AnyDecodable : Swift.Decodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyDecodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension AnyDecodable : NotificareKit._AnyDecodable {
}
extension _AnyDecodable {
  public init(from decoder: Swift.Decoder) throws
}
extension AnyDecodable : Swift.Equatable {
  public static func == (lhs: NotificareKit.AnyDecodable, rhs: NotificareKit.AnyDecodable) -> Swift.Bool
}
extension AnyDecodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AnyDecodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension URLRequest {
  public mutating func setBasicAuthentication(username: Swift.String, password: Swift.String)
  public mutating func setBearerAuthentication(token: Swift.String)
  public mutating func setNotificareHeaders()
  public mutating func setMethod(_ method: Swift.String, payload: Foundation.Data? = nil)
}
extension URLSession {
  public static var maximumNumberOfRetries: Swift.Int
  public typealias DataResult = Swift.Result<(response: Foundation.HTTPURLResponse, data: Foundation.Data?), NotificareKit.NotificareNetworkError>
  public typealias Callback = (Foundation.URLSession.DataResult) -> Swift.Void
  public func perform(_ urlRequest: Foundation.URLRequest, maxRetries: Swift.Int = URLSession.maximumNumberOfRetries, allowEmptyData: Swift.Bool = false, callback: @escaping Foundation.URLSession.Callback)
}
public struct NotificareRequest {
  public func response(_ completion: @escaping (Swift.Result<(response: Foundation.HTTPURLResponse, data: Foundation.Data?), Swift.Error>) -> Swift.Void)
  public func responseDecodable<T>(_ type: T.Type, _ completion: @escaping (Swift.Result<T, Swift.Error>) -> Swift.Void) where T : Swift.Decodable
  public class Builder {
    public init()
    public func baseUrl(url: Swift.String) -> Self
    public func get(_ url: Swift.String) -> Self
    public func patch(_ url: Swift.String) -> Self
    public func patch<T>(_ url: Swift.String, body: T?) -> Self where T : Swift.Encodable
    public func post(_ url: Swift.String) -> Self
    public func post<T>(_ url: Swift.String, body: T?) -> Self where T : Swift.Encodable
    public func post(_ url: Swift.String, body: Foundation.Data, contentType: Swift.String) -> Self
    public func put(_ url: Swift.String) -> Self
    public func put<T>(_ url: Swift.String, body: T?) -> Self where T : Swift.Encodable
    public func delete(_ url: Swift.String) -> Self
    public func delete<T>(_ url: Swift.String, body: T?) -> Self where T : Swift.Encodable
    public func query(items: [Swift.String : Swift.String?]) -> Self
    public func query(name: Swift.String, value: Swift.String?) -> Self
    public func header(name: Swift.String, value: Swift.String?) -> Self
    public func validate(range: Swift.ClosedRange<Swift.Int>) -> Self
    public func build() throws -> NotificareKit.NotificareRequest
    public func response(_ completion: @escaping (Swift.Result<(response: Foundation.HTTPURLResponse, data: Foundation.Data?), Swift.Error>) -> Swift.Void)
    public func responseDecodable<T>(_ type: T.Type, _ completion: @escaping (Swift.Result<T, Swift.Error>) -> Swift.Void) where T : Swift.Decodable
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class NotificareLocalizable {
  public static func string(resource: NotificareKit.NotificareLocalizable.StringResource) -> Swift.String
  public static func string(resource: Swift.String, fallback: Swift.String) -> Swift.String
  public static func image(resource: NotificareKit.NotificareLocalizable.ImageResource) -> UIKit.UIImage?
  public enum StringResource : Swift.String {
    case ok
    case cancel
    case actions
    case pushDefaultCategory
    case actionsSend
    case actionsInputPlaceholder
    case actionsShareImageTextPlaceholder
    case rateAlertYesButton
    case rateAlertNoButton
    case mapUnknownTitleMarker
    case actionMailSubject
    case actionMailBody
    case closeButton
    case sendButton
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ImageResource : Swift.String {
    case actions
    case mapMarker
    case mapMarkerUserLocation
    case close
    case send
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
extension Dictionary {
  public func mapKeys<Transformed>(_ transform: (Key) throws -> Transformed) rethrows -> [Transformed : Value] where Transformed : Swift.Hashable
}
extension Data {
  public func toHexString() -> Swift.String
}
@_hasMissingDesignatedInitializers public class NotificareDeviceManager {
  public var currentDevice: NotificareKit.NotificareDevice? {
    get
  }
  public var preferredLanguage: Swift.String? {
    get
  }
  public func register(userId: Swift.String?, userName: Swift.String?, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  public func updatePreferredLanguage(_ preferredLanguage: Swift.String?, _ completion: @escaping NotificareKit.NotificareCallback<Swift.String?>)
  public func fetchTags(_ completion: @escaping NotificareKit.NotificareCallback<[Swift.String]>)
  public func addTag(_ tag: Swift.String, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  public func addTags(_ tags: [Swift.String], _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  public func removeTag(_ tag: Swift.String, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  public func removeTags(_ tags: [Swift.String], _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  public func clearTags(_ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  public func fetchDoNotDisturb(_ completion: @escaping NotificareKit.NotificareCallback<NotificareKit.NotificareDoNotDisturb?>)
  public func updateDoNotDisturb(_ dnd: NotificareKit.NotificareDoNotDisturb, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  public func clearDoNotDisturb(_ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  public func fetchUserData(_ completion: @escaping NotificareKit.NotificareCallback<NotificareKit.NotificareUserData>)
  public func updateUserData(_ userData: NotificareKit.NotificareUserData, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  public func registerTemporary(_ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  public func registerAPNS(token: Swift.String, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class NotificareEventsModule {
  public func logApplicationInstall(_ completion: NotificareKit.NotificareCallback<Swift.Void>? = nil)
  public func logApplicationRegistration(_ completion: NotificareKit.NotificareCallback<Swift.Void>? = nil)
  public func logApplicationUpgrade(_ completion: NotificareKit.NotificareCallback<Swift.Void>? = nil)
  public func logApplicationOpen(_ completion: NotificareKit.NotificareCallback<Swift.Void>? = nil)
  public func logApplicationClose(length: Foundation.TimeInterval, _ completion: NotificareKit.NotificareCallback<Swift.Void>? = nil)
  public func logNotificationOpen(_ notification: NotificareKit.NotificareNotification, _ completion: NotificareKit.NotificareCallback<Swift.Void>? = nil)
  public func logNotificationOpen(_ notificationId: Swift.String, _ completion: NotificareKit.NotificareCallback<Swift.Void>? = nil)
  public func logCustom(_ event: Swift.String, data: NotificareKit.NotificareEventData? = nil, _ completion: NotificareKit.NotificareCallback<Swift.Void>? = nil)
  public func log(_ event: Swift.String, data: NotificareKit.NotificareEventData? = nil, for notification: Swift.String? = nil, _ completion: NotificareKit.NotificareCallback<Swift.Void>? = nil)
  @objc deinit
}
extension NotificareEventsModule : NotificareKit.NotificareAppDelegateInterceptor {
  @objc dynamic public func applicationDidBecomeActive(_: UIKit.UIApplication)
}
extension UIColor {
  convenience public init(hexString: Swift.String, alpha: CoreGraphics.CGFloat = 1.0)
  public func toHexString() -> Swift.String
}
public struct JSON {
  public var value: Any {
    get
  }
  public init()
  public init(_ value: Any?)
}
extension JSON : Swift.RawRepresentable {
  public init?(rawValue: Foundation.Data)
  public var rawValue: Foundation.Data {
    get
  }
  public typealias RawValue = Foundation.Data
}
extension JSON : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension JSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension JSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension JSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension JSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension JSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension JSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
public struct NotificareOptions {
  public let autoConfig: Swift.Bool
  public let swizzlingEnabled: Swift.Bool
  public let userNotificationCenterDelegateEnabled: Swift.Bool
  public let crashReportsEnabled: Swift.Bool
  public let urlSchemes: [Swift.String]
  public let closeWindowQueryParameter: Swift.String?
  public let imageSharingEnabled: Swift.Bool
  public let safariDismissButtonStyle: Swift.Int?
  public let themes: NotificareKit.NotificareOptions.Themes?
  public struct Themes : Swift.Decodable {
    public let light: NotificareKit.NotificareOptions.Theme?
    public let dark: NotificareKit.NotificareOptions.Theme?
    public init(from decoder: Swift.Decoder) throws
  }
  public struct Theme : Swift.Decodable {
    public let backgroundColor: Swift.String?
    public let actionButtonTextColor: Swift.String?
    public let toolbarBackgroundColor: Swift.String?
    public let activityIndicatorColor: Swift.String?
    public let buttonTextColor: Swift.String?
    public let textFieldTextColor: Swift.String?
    public let textFieldBackgroundColor: Swift.String?
    public let safariBarTintColor: Swift.String?
    public let safariControlsTintColor: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
}
extension NotificareOptions : Swift.Decodable {
  public init()
  public init?(contentsOfFile plistPath: Swift.String)
  public init(from decoder: Swift.Decoder) throws
}
extension NotificareOptions {
  public func theme(for controller: UIKit.UIViewController) -> NotificareKit.NotificareOptions.Theme?
}
extension JSON : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_inheritsConvenienceInitializers @objc(NotificareCoreDataEvent) public class NotificareCoreDataEvent : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension NotificareCoreDataEvent {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<NotificareKit.NotificareCoreDataEvent>
  @objc @NSManaged dynamic public var data: Foundation.Data? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var deviceId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var notificationId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var retries: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var sessionId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var timestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var ttl: Swift.Int32 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var type: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var userId: Swift.String? {
    @objc get
    @objc set
  }
}
extension NotificareKit.NotificareNotification.NotificationType : Swift.Equatable {}
extension NotificareKit.NotificareNotification.NotificationType : Swift.Hashable {}
extension NotificareKit.NotificareNotification.NotificationType : Swift.RawRepresentable {}
extension NotificareKit.NotificareNotification.Action.ActionType : Swift.Equatable {}
extension NotificareKit.NotificareNotification.Action.ActionType : Swift.Hashable {}
extension NotificareKit.NotificareNotification.Action.ActionType : Swift.RawRepresentable {}
extension NotificareKit.NotificareTransport : Swift.Equatable {}
extension NotificareKit.NotificareTransport : Swift.Hashable {}
extension NotificareKit.NotificareTransport : Swift.RawRepresentable {}
extension NotificareKit.NotificareReachability.Connection : Swift.Equatable {}
extension NotificareKit.NotificareReachability.Connection : Swift.Hashable {}
extension NotificareKit.NotificareDefinitions.Modules : Swift.Equatable {}
extension NotificareKit.NotificareDefinitions.Modules : Swift.Hashable {}
extension NotificareKit.NotificareDefinitions.Modules : Swift.RawRepresentable {}
extension NotificareKit.NotificareLocalizable.StringResource : Swift.Equatable {}
extension NotificareKit.NotificareLocalizable.StringResource : Swift.Hashable {}
extension NotificareKit.NotificareLocalizable.StringResource : Swift.RawRepresentable {}
extension NotificareKit.NotificareLocalizable.ImageResource : Swift.Equatable {}
extension NotificareKit.NotificareLocalizable.ImageResource : Swift.Hashable {}
extension NotificareKit.NotificareLocalizable.ImageResource : Swift.RawRepresentable {}
